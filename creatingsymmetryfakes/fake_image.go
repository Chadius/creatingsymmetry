// Code generated by counterfeiter. DO NOT EDIT.
package creatingsymmetryfakes

import (
	"image"
	"image/color"
	"sync"
)

type FakeImage struct {
	AtStub        func(int, int) color.Color
	atMutex       sync.RWMutex
	atArgsForCall []struct {
		arg1 int
		arg2 int
	}
	atReturns struct {
		result1 color.Color
	}
	atReturnsOnCall map[int]struct {
		result1 color.Color
	}
	BoundsStub        func() image.Rectangle
	boundsMutex       sync.RWMutex
	boundsArgsForCall []struct {
	}
	boundsReturns struct {
		result1 image.Rectangle
	}
	boundsReturnsOnCall map[int]struct {
		result1 image.Rectangle
	}
	ColorModelStub        func() color.Model
	colorModelMutex       sync.RWMutex
	colorModelArgsForCall []struct {
	}
	colorModelReturns struct {
		result1 color.Model
	}
	colorModelReturnsOnCall map[int]struct {
		result1 color.Model
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeImage) At(arg1 int, arg2 int) color.Color {
	fake.atMutex.Lock()
	ret, specificReturn := fake.atReturnsOnCall[len(fake.atArgsForCall)]
	fake.atArgsForCall = append(fake.atArgsForCall, struct {
		arg1 int
		arg2 int
	}{arg1, arg2})
	stub := fake.AtStub
	fakeReturns := fake.atReturns
	fake.recordInvocation("At", []interface{}{arg1, arg2})
	fake.atMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeImage) AtCallCount() int {
	fake.atMutex.RLock()
	defer fake.atMutex.RUnlock()
	return len(fake.atArgsForCall)
}

func (fake *FakeImage) AtCalls(stub func(int, int) color.Color) {
	fake.atMutex.Lock()
	defer fake.atMutex.Unlock()
	fake.AtStub = stub
}

func (fake *FakeImage) AtArgsForCall(i int) (int, int) {
	fake.atMutex.RLock()
	defer fake.atMutex.RUnlock()
	argsForCall := fake.atArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeImage) AtReturns(result1 color.Color) {
	fake.atMutex.Lock()
	defer fake.atMutex.Unlock()
	fake.AtStub = nil
	fake.atReturns = struct {
		result1 color.Color
	}{result1}
}

func (fake *FakeImage) AtReturnsOnCall(i int, result1 color.Color) {
	fake.atMutex.Lock()
	defer fake.atMutex.Unlock()
	fake.AtStub = nil
	if fake.atReturnsOnCall == nil {
		fake.atReturnsOnCall = make(map[int]struct {
			result1 color.Color
		})
	}
	fake.atReturnsOnCall[i] = struct {
		result1 color.Color
	}{result1}
}

func (fake *FakeImage) Bounds() image.Rectangle {
	fake.boundsMutex.Lock()
	ret, specificReturn := fake.boundsReturnsOnCall[len(fake.boundsArgsForCall)]
	fake.boundsArgsForCall = append(fake.boundsArgsForCall, struct {
	}{})
	stub := fake.BoundsStub
	fakeReturns := fake.boundsReturns
	fake.recordInvocation("Bounds", []interface{}{})
	fake.boundsMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeImage) BoundsCallCount() int {
	fake.boundsMutex.RLock()
	defer fake.boundsMutex.RUnlock()
	return len(fake.boundsArgsForCall)
}

func (fake *FakeImage) BoundsCalls(stub func() image.Rectangle) {
	fake.boundsMutex.Lock()
	defer fake.boundsMutex.Unlock()
	fake.BoundsStub = stub
}

func (fake *FakeImage) BoundsReturns(result1 image.Rectangle) {
	fake.boundsMutex.Lock()
	defer fake.boundsMutex.Unlock()
	fake.BoundsStub = nil
	fake.boundsReturns = struct {
		result1 image.Rectangle
	}{result1}
}

func (fake *FakeImage) BoundsReturnsOnCall(i int, result1 image.Rectangle) {
	fake.boundsMutex.Lock()
	defer fake.boundsMutex.Unlock()
	fake.BoundsStub = nil
	if fake.boundsReturnsOnCall == nil {
		fake.boundsReturnsOnCall = make(map[int]struct {
			result1 image.Rectangle
		})
	}
	fake.boundsReturnsOnCall[i] = struct {
		result1 image.Rectangle
	}{result1}
}

func (fake *FakeImage) ColorModel() color.Model {
	fake.colorModelMutex.Lock()
	ret, specificReturn := fake.colorModelReturnsOnCall[len(fake.colorModelArgsForCall)]
	fake.colorModelArgsForCall = append(fake.colorModelArgsForCall, struct {
	}{})
	stub := fake.ColorModelStub
	fakeReturns := fake.colorModelReturns
	fake.recordInvocation("ColorModel", []interface{}{})
	fake.colorModelMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeImage) ColorModelCallCount() int {
	fake.colorModelMutex.RLock()
	defer fake.colorModelMutex.RUnlock()
	return len(fake.colorModelArgsForCall)
}

func (fake *FakeImage) ColorModelCalls(stub func() color.Model) {
	fake.colorModelMutex.Lock()
	defer fake.colorModelMutex.Unlock()
	fake.ColorModelStub = stub
}

func (fake *FakeImage) ColorModelReturns(result1 color.Model) {
	fake.colorModelMutex.Lock()
	defer fake.colorModelMutex.Unlock()
	fake.ColorModelStub = nil
	fake.colorModelReturns = struct {
		result1 color.Model
	}{result1}
}

func (fake *FakeImage) ColorModelReturnsOnCall(i int, result1 color.Model) {
	fake.colorModelMutex.Lock()
	defer fake.colorModelMutex.Unlock()
	fake.ColorModelStub = nil
	if fake.colorModelReturnsOnCall == nil {
		fake.colorModelReturnsOnCall = make(map[int]struct {
			result1 color.Model
		})
	}
	fake.colorModelReturnsOnCall[i] = struct {
		result1 color.Model
	}{result1}
}

func (fake *FakeImage) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.atMutex.RLock()
	defer fake.atMutex.RUnlock()
	fake.boundsMutex.RLock()
	defer fake.boundsMutex.RUnlock()
	fake.colorModelMutex.RLock()
	defer fake.colorModelMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeImage) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ image.Image = new(FakeImage)
